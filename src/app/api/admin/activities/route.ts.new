import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth/next'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/prisma'
import { Photographer, Gallery, Client, PurchaseRequest } from '@prisma/client'

interface Activity {
  id: string
  type: string
  title: string
  description: string
  timestamp: Date
  status: string
  metadata?: Record<string, string | number | boolean | null>
}

interface PhotographerWithUser extends Photographer {
  user: {
    name: string | null
    email: string | null
  }
}

interface GalleryWithPhotographer extends Gallery {
  photographer: {
    id: string
    user: {
      name: string | null
    }
  } | null
}

interface ClientWithUser extends Client {
  user: {
    name: string | null
    email: string | null
  } | null
}

interface PurchaseWithDetails extends PurchaseRequest {
  client: {
    id: string
    user: {
      name: string | null
      email: string | null
    } | null
  } | null
  photo: {
    id: string
    title: string | null
    filename: string
  } | null
}

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    // Check if user is authenticated and has admin role
    if (!session || session.user.role !== 'admin') {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const { searchParams } = new URL(request.url)
    const limit = parseInt(searchParams.get('limit') || '10')
    const offset = parseInt(searchParams.get('offset') || '0')

    // Get recent activities from various sources
    const activities: Activity[] = []

    // Recent photographer registrations
    const recentPhotographers = await prisma.photographer.findMany({
      take: 5,
      orderBy: { createdAt: 'desc' },
      include: {
        user: {
          select: { name: true, email: true }
        }
      }
    }) as PhotographerWithUser[]

    recentPhotographers.forEach((photographer) => {
      activities.push({
        id: `photographer-${photographer.id}`,
        type: 'photographer_registration',
        title: 'New photographer registration',
        description: `${photographer.user.name || photographer.user.email} registered as a photographer`,
        timestamp: photographer.createdAt,
        status: photographer.status,
        metadata: {
          photographerId: photographer.id,
          photographerName: photographer.user.name ?? null,
          photographerEmail: photographer.user.email ?? null
        }
      })
    })

    // Recent galleries
    const recentGalleries = await prisma.gallery.findMany({
      take: 5,
      orderBy: { createdAt: 'desc' },
      include: {
        photographer: {
          include: {
            user: {
              select: {
                name: true
              }
            }
          }
        }
      }
    }) as GalleryWithPhotographer[]

    recentGalleries.forEach((gallery) => {
      activities.push({
        id: `gallery-${gallery.id}`,
        type: 'gallery_created',
        title: 'New gallery created',
        description: `Gallery "${gallery.title}" was created`,
        timestamp: gallery.createdAt,
        status: gallery.status,
        metadata: {
          galleryId: gallery.id,
          galleryTitle: gallery.title,
          photographerId: gallery.photographer?.id ?? null,
          photographerName: gallery.photographer?.user?.name ?? null
        }
      })
    })

    // Recent clients
    const recentClients = await prisma.client.findMany({
      take: limit,
      skip: offset,
      orderBy: { createdAt: 'desc' },
      include: {
        user: {
          select: {
            name: true,
            email: true
          }
        }
      }
    }) as ClientWithUser[]

    recentClients.forEach((client) => {
      if (client.user) {
        activities.push({
          id: `client-${client.id}`,
          type: 'client_registration',
          title: 'New client registered',
          description: `${client.user.name || client.user.email || client.email} registered as a client`,
          timestamp: client.createdAt,
          status: 'active',
          metadata: {
            clientId: client.id,
            clientName: client.user.name ?? null,
            clientEmail: client.user.email ?? client.email
          }
        })
      }
    })

    // Recent purchase requests
    const recentPurchases = await prisma.purchaseRequest.findMany({
      take: 5,
      orderBy: { createdAt: 'desc' },
      include: {
        client: {
          include: {
            user: {
              select: { name: true, email: true }
            }
          }
        },
        photo: {
          select: { id: true, title: true, filename: true }
        }
      }
    }) as PurchaseWithDetails[]

    recentPurchases.forEach((purchase) => {
      activities.push({
        id: `purchase-${purchase.id}`,
        type: 'purchase_request',
        title: 'New purchase request',
        description: `${purchase.client?.user?.name || purchase.client?.user?.email || 'Unknown user'} requested to purchase "${purchase.photo?.title || purchase.photo?.filename || 'Untitled'}"`,
        timestamp: purchase.createdAt,
        status: purchase.status,
        metadata: {
          purchaseId: purchase.id,
          clientId: purchase.client?.id ?? null,
          clientName: purchase.client?.user?.name ?? null,
          photoId: purchase.photo?.id ?? null,
          photoTitle: purchase.photo?.title ?? null,
          licenseType: purchase.licenseType ?? null,
          price: purchase.price
        }
      })
    })

    // Sort all activities by timestamp (newest first)
    activities.sort((a: Activity, b: Activity) => 
      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
    )

    // Apply pagination
    const paginatedActivities = activities.slice(offset, offset + limit)

    return NextResponse.json({
      activities: paginatedActivities,
      total: activities.length,
      hasMore: offset + limit < activities.length
    })

  } catch (error) {
    console.error('Error fetching admin activities:', error)
    return NextResponse.json(
      { error: 'Failed to fetch activities' },
      { status: 500 }
    )
  }
}
